-- Migration: 025_director_and_evaluations.sql
-- Purpose: Add Director tracking to sessions and create evaluations table for shareable results
-- Reference: docs/DIRECTOR_ARCHITECTURE.md, docs/plans/FLIRT_TEST_IMPLEMENTATION_PLAN.md
-- Date: 2025-12-19

-- ============================================================================
-- PHASE 1: EXTEND SESSIONS FOR DIRECTOR TRACKING
-- ============================================================================

-- Add turn tracking for bounded episodes
ALTER TABLE sessions ADD COLUMN IF NOT EXISTS turn_count INTEGER DEFAULT 0;

-- Add Director state for cross-turn tracking (tension, beat progression, etc.)
ALTER TABLE sessions ADD COLUMN IF NOT EXISTS director_state JSONB DEFAULT '{}';

-- Add completion trigger tracking (what caused completion: turn_limit, beat_gate, objective, etc.)
ALTER TABLE sessions ADD COLUMN IF NOT EXISTS completion_trigger TEXT;

-- Index for Director state queries (GIN for JSONB containment queries)
CREATE INDEX IF NOT EXISTS idx_sessions_director_state ON sessions USING GIN(director_state);

-- ============================================================================
-- PHASE 2: EXTEND EPISODE_TEMPLATES FOR COMPLETION MODES
-- ============================================================================

-- Add completion mode (how the episode ends)
-- - 'open': No defined end, fade naturally (default, current behavior)
-- - 'turn_limited': Ends after N turns (games, tests)
-- - 'beat_gated': Ends when specific beat is reached (mystery, thriller)
-- - 'objective': Ends when objective is achieved (puzzles)
ALTER TABLE episode_templates ADD COLUMN IF NOT EXISTS completion_mode TEXT DEFAULT 'open';

-- Add turn budget for turn_limited episodes
ALTER TABLE episode_templates ADD COLUMN IF NOT EXISTS turn_budget INTEGER;

-- Add completion criteria (flexible JSONB for different modes)
-- Examples:
--   turn_limited: {} (just uses turn_budget)
--   beat_gated: {"required_beat": "revelation"}
--   objective: {"objective": "find_the_killer", "clues_needed": 3}
ALTER TABLE episode_templates ADD COLUMN IF NOT EXISTS completion_criteria JSONB DEFAULT '{}';

-- Add constraint for completion_mode values
ALTER TABLE episode_templates DROP CONSTRAINT IF EXISTS episode_templates_completion_mode_check;
ALTER TABLE episode_templates ADD CONSTRAINT episode_templates_completion_mode_check
    CHECK (completion_mode IN ('open', 'turn_limited', 'beat_gated', 'objective'));

-- Index for completion mode queries
CREATE INDEX IF NOT EXISTS idx_episode_templates_completion_mode ON episode_templates(completion_mode);

-- ============================================================================
-- PHASE 3: CREATE SESSION_EVALUATIONS TABLE
-- ============================================================================

-- Evaluations are "reports" generated by Director at episode completion
-- They're the shareable results (flirt archetype, mystery summary, etc.)
CREATE TABLE IF NOT EXISTS session_evaluations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,

    -- Evaluation identity
    evaluation_type TEXT NOT NULL,  -- 'flirt_archetype', 'mystery_summary', 'compatibility', etc.

    -- The evaluation result (schema depends on evaluation_type)
    -- flirt_archetype example:
    -- {
    --   "archetype": "tension_builder",
    --   "confidence": 0.85,
    --   "primary_signals": ["pause_mastery", "anticipation_building"],
    --   "title": "The Tension Builder",
    --   "description": "You know exactly when to pause..."
    -- }
    result JSONB NOT NULL,

    -- Share infrastructure
    share_id TEXT UNIQUE,  -- Short hash for share URL: ep-0.com/r/{share_id}
    share_count INTEGER DEFAULT 0,

    -- LLM tracking
    model_used TEXT,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for share lookups (most common query)
CREATE INDEX IF NOT EXISTS idx_session_evaluations_share_id ON session_evaluations(share_id) WHERE share_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_session_evaluations_session ON session_evaluations(session_id);
CREATE INDEX IF NOT EXISTS idx_session_evaluations_type ON session_evaluations(evaluation_type);

-- ============================================================================
-- PHASE 4: ROW LEVEL SECURITY FOR SESSION_EVALUATIONS
-- ============================================================================

ALTER TABLE session_evaluations ENABLE ROW LEVEL SECURITY;

-- Anyone can read evaluations with a share_id (for share links)
CREATE POLICY "Evaluations with share_id are publicly readable"
    ON session_evaluations FOR SELECT
    USING (share_id IS NOT NULL);

-- Users can read their own evaluations (via session ownership)
CREATE POLICY "Users can read own evaluations"
    ON session_evaluations FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM sessions
            WHERE sessions.id = session_evaluations.session_id
            AND sessions.user_id = auth.uid()
        )
    );

-- Service role has full access (for API to create evaluations)
CREATE POLICY "Service role can manage evaluations"
    ON session_evaluations FOR ALL
    TO service_role
    USING (true)
    WITH CHECK (true);

-- ============================================================================
-- PHASE 5: FUNCTION TO INCREMENT SHARE COUNT
-- ============================================================================

CREATE OR REPLACE FUNCTION increment_share_count(p_share_id TEXT)
RETURNS VOID AS $$
BEGIN
    UPDATE session_evaluations
    SET share_count = share_count + 1
    WHERE share_id = p_share_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute to authenticated and anon (for tracking shares)
GRANT EXECUTE ON FUNCTION increment_share_count(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION increment_share_count(TEXT) TO anon;

-- ============================================================================
-- VERIFICATION
-- ============================================================================

DO $$
DECLARE
    turn_count_exists BOOLEAN;
    director_state_exists BOOLEAN;
    completion_mode_exists BOOLEAN;
    evaluations_exists BOOLEAN;
BEGIN
    -- Check sessions extensions
    SELECT EXISTS (
        SELECT FROM information_schema.columns
        WHERE table_name = 'sessions' AND column_name = 'turn_count'
    ) INTO turn_count_exists;

    SELECT EXISTS (
        SELECT FROM information_schema.columns
        WHERE table_name = 'sessions' AND column_name = 'director_state'
    ) INTO director_state_exists;

    -- Check episode_templates extensions
    SELECT EXISTS (
        SELECT FROM information_schema.columns
        WHERE table_name = 'episode_templates' AND column_name = 'completion_mode'
    ) INTO completion_mode_exists;

    -- Check session_evaluations table
    SELECT EXISTS (
        SELECT FROM information_schema.tables
        WHERE table_name = 'session_evaluations'
    ) INTO evaluations_exists;

    IF NOT turn_count_exists THEN
        RAISE EXCEPTION 'Migration failed: sessions.turn_count not added';
    END IF;

    IF NOT director_state_exists THEN
        RAISE EXCEPTION 'Migration failed: sessions.director_state not added';
    END IF;

    IF NOT completion_mode_exists THEN
        RAISE EXCEPTION 'Migration failed: episode_templates.completion_mode not added';
    END IF;

    IF NOT evaluations_exists THEN
        RAISE EXCEPTION 'Migration failed: session_evaluations table not created';
    END IF;

    RAISE NOTICE 'Migration 025_director_and_evaluations completed successfully';
    RAISE NOTICE 'Added: sessions.turn_count, sessions.director_state, sessions.completion_trigger';
    RAISE NOTICE 'Added: episode_templates.completion_mode, turn_budget, completion_criteria';
    RAISE NOTICE 'Created: session_evaluations table with RLS policies';
END $$;
