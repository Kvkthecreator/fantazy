-- Migration: 010_avatar_domain
-- Description: Avatar management domain - visual identity contracts for characters
--
-- This migration introduces a proper avatar system where:
-- - avatar_kits define the visual identity contract (prompts + anchors)
-- - avatar_assets store canonical character images (anchors, expressions)
-- - scene_images (renamed from episode_images) reference the kit used
--
-- Key changes:
-- 1. NEW: avatar_kits table
-- 2. NEW: avatar_assets table
-- 3. RENAME: episode_images → scene_images (with new columns)
-- 4. ADD: characters.active_avatar_kit_id
-- 5. DEPRECATE: character_expressions (replaced by avatar_assets)
-- 6. CLARIFY: image_assets is now for non-character images only

-- ============================================================================
-- AVATAR_KITS table
-- The visual identity contract - defines what a character looks like
-- ============================================================================
CREATE TABLE IF NOT EXISTS avatar_kits (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Ownership
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    created_by UUID REFERENCES users(id) ON DELETE SET NULL,

    -- Identity
    name TEXT NOT NULL,                    -- "Yuki Default", "Yuki Summer"
    description TEXT,                      -- Internal notes

    -- Visual Contract (the "model sheet" text)
    appearance_prompt TEXT NOT NULL,       -- Physical description for image prompts
                                           -- "Young woman, shoulder-length black hair, warm brown eyes,
                                           --  soft features, slight smile, cream cardigan..."

    style_prompt TEXT NOT NULL,            -- Art style rules
                                           -- "Anime style, soft cel shading, warm color palette,
                                           --  Studio Ghibli-inspired, gentle lighting..."

    negative_prompt TEXT,                  -- What to avoid in generation
                                           -- "photorealistic, 3D render, multiple people,
                                           --  different hairstyle, different eye color..."

    -- Anchor References (set after assets are uploaded)
    -- These are the canonical images that define the character's look
    primary_anchor_id UUID,                -- Portrait anchor (face reference)
    secondary_anchor_id UUID,              -- Full-body anchor

    -- Kit Status
    status TEXT NOT NULL DEFAULT 'draft'
        CHECK (status IN ('draft', 'active', 'archived')),
    is_default BOOLEAN DEFAULT FALSE,      -- Default kit for this character

    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================================================
-- AVATAR_ASSETS table
-- Canonical images that define a character's visual identity
-- ============================================================================
CREATE TABLE IF NOT EXISTS avatar_assets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Parent kit
    avatar_kit_id UUID NOT NULL REFERENCES avatar_kits(id) ON DELETE CASCADE,

    -- Classification
    asset_type TEXT NOT NULL CHECK (asset_type IN (
        'anchor_portrait',      -- Primary face reference (shoulders up)
        'anchor_fullbody',      -- Full body reference
        'expression',           -- Expression variant (derived from anchor)
        'pose',                 -- Pose variant
        'outfit'                -- Outfit variant (future)
    )),

    expression TEXT,            -- For expression/pose assets: 'neutral', 'happy', 'shy', etc.
    emotion_tags TEXT[],        -- Maps emotions to this asset: ['joy', 'excitement'] -> 'happy'

    -- Storage
    storage_bucket TEXT NOT NULL DEFAULT 'avatars',
    storage_path TEXT NOT NULL,  -- {kit_id}/anchors/{id}.png

    -- Generation Provenance
    source_type TEXT NOT NULL CHECK (source_type IN (
        'manual_upload',        -- Admin uploaded
        'ai_generated',         -- Generated by ImageService
        'imported'              -- Imported from external source
    )),
    derived_from_id UUID REFERENCES avatar_assets(id) ON DELETE SET NULL,

    generation_metadata JSONB DEFAULT '{}',  -- {
                                              --   "provider": "replicate",
                                              --   "model": "flux-kontext-pro",
                                              --   "prompt": "...",
                                              --   "reference_asset_ids": [...],
                                              --   "latency_ms": 5200
                                              -- }

    -- Image Properties
    mime_type TEXT DEFAULT 'image/png',
    width INTEGER,
    height INTEGER,
    file_size_bytes INTEGER,

    -- Status
    is_canonical BOOLEAN DEFAULT FALSE,  -- TRUE for anchors
    is_active BOOLEAN DEFAULT TRUE,      -- Soft delete

    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================================================
-- Add FK constraints for anchor references (after avatar_assets exists)
-- ============================================================================
ALTER TABLE avatar_kits
ADD CONSTRAINT fk_avatar_kits_primary_anchor
    FOREIGN KEY (primary_anchor_id) REFERENCES avatar_assets(id) ON DELETE SET NULL;

ALTER TABLE avatar_kits
ADD CONSTRAINT fk_avatar_kits_secondary_anchor
    FOREIGN KEY (secondary_anchor_id) REFERENCES avatar_assets(id) ON DELETE SET NULL;

-- ============================================================================
-- CHARACTERS table extension
-- Link character to their active visual identity
-- ============================================================================
ALTER TABLE characters
ADD COLUMN IF NOT EXISTS active_avatar_kit_id UUID REFERENCES avatar_kits(id) ON DELETE SET NULL;

-- ============================================================================
-- RENAME episode_images → scene_images
-- Add kit reference for consistency tracking
-- ============================================================================

-- Rename the table
ALTER TABLE IF EXISTS episode_images RENAME TO scene_images;

-- Add new columns for avatar kit tracking
ALTER TABLE scene_images
ADD COLUMN IF NOT EXISTS avatar_kit_id UUID REFERENCES avatar_kits(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS derived_from_asset_id UUID REFERENCES avatar_assets(id) ON DELETE SET NULL;

-- Update indexes to use new table name
DROP INDEX IF EXISTS idx_episode_images_episode;
DROP INDEX IF EXISTS idx_episode_images_image;
DROP INDEX IF EXISTS idx_episode_images_memories;

CREATE INDEX IF NOT EXISTS idx_scene_images_episode ON scene_images(episode_id);
CREATE INDEX IF NOT EXISTS idx_scene_images_image ON scene_images(image_id);
CREATE INDEX IF NOT EXISTS idx_scene_images_memories ON scene_images(is_memory) WHERE is_memory = TRUE;
CREATE INDEX IF NOT EXISTS idx_scene_images_kit ON scene_images(avatar_kit_id);

-- ============================================================================
-- DEPRECATE character_expressions
-- This table is replaced by avatar_assets with asset_type='expression'
-- We keep the table but add a deprecation comment
-- ============================================================================
COMMENT ON TABLE character_expressions IS
'DEPRECATED: Use avatar_assets with asset_type=''expression'' instead.
This table will be removed in a future migration after data is migrated.';

-- ============================================================================
-- CLARIFY image_assets purpose
-- This table is now for non-character images only (backgrounds, props, world assets)
-- ============================================================================
COMMENT ON TABLE image_assets IS
'Generic image assets for non-character images (backgrounds, props, world elements).
For character-specific visuals (avatars, expressions), use avatar_assets instead.
The type CHECK constraint allows: avatar, expression, scene
- avatar/expression: DEPRECATED for new use, prefer avatar_assets
- scene: Still used for user-generated scene outputs (legacy, prefer scene_images)';

-- ============================================================================
-- Enable RLS on new tables
-- ============================================================================
ALTER TABLE avatar_kits ENABLE ROW LEVEL SECURITY;
ALTER TABLE avatar_assets ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- AVATAR_KITS Policies
-- Kits are public read (shared canonical assets), admin write
-- ============================================================================

-- Everyone can see active kits
CREATE POLICY avatar_kits_select_active ON avatar_kits
    FOR SELECT TO authenticated
    USING (status = 'active');

-- Service role can manage all kits
CREATE POLICY avatar_kits_service ON avatar_kits
    FOR ALL TO service_role USING (TRUE);

-- ============================================================================
-- AVATAR_ASSETS Policies
-- Assets are public read (shared canonical assets), admin write
-- ============================================================================

-- Everyone can see active assets
CREATE POLICY avatar_assets_select_active ON avatar_assets
    FOR SELECT TO authenticated
    USING (is_active = TRUE);

-- Service role can manage all assets
CREATE POLICY avatar_assets_service ON avatar_assets
    FOR ALL TO service_role USING (TRUE);

-- ============================================================================
-- Update scene_images policies (renamed from episode_images)
-- ============================================================================

-- Drop old policies if they exist
DROP POLICY IF EXISTS episode_images_select_own ON scene_images;
DROP POLICY IF EXISTS episode_images_insert_own ON scene_images;
DROP POLICY IF EXISTS episode_images_update_own ON scene_images;

-- Recreate with correct table name
CREATE POLICY scene_images_select_own ON scene_images
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM episodes
            WHERE episodes.id = scene_images.episode_id
            AND episodes.user_id = auth.uid()
        )
    );

CREATE POLICY scene_images_insert_own ON scene_images
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM episodes
            WHERE episodes.id = scene_images.episode_id
            AND episodes.user_id = auth.uid()
        )
    );

CREATE POLICY scene_images_update_own ON scene_images
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM episodes
            WHERE episodes.id = scene_images.episode_id
            AND episodes.user_id = auth.uid()
        )
    );

-- Service role can manage all
CREATE POLICY scene_images_service ON scene_images
    FOR ALL TO service_role USING (TRUE);

-- ============================================================================
-- Indexes for new tables
-- ============================================================================

-- Avatar kits
CREATE INDEX IF NOT EXISTS idx_avatar_kits_character ON avatar_kits(character_id);
CREATE INDEX IF NOT EXISTS idx_avatar_kits_status ON avatar_kits(status) WHERE status = 'active';

-- Only one default kit per character
CREATE UNIQUE INDEX IF NOT EXISTS idx_avatar_kits_default
ON avatar_kits(character_id)
WHERE is_default = TRUE;

-- Avatar assets
CREATE INDEX IF NOT EXISTS idx_avatar_assets_kit ON avatar_assets(avatar_kit_id);
CREATE INDEX IF NOT EXISTS idx_avatar_assets_type ON avatar_assets(asset_type);
CREATE INDEX IF NOT EXISTS idx_avatar_assets_expression ON avatar_assets(expression) WHERE expression IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_avatar_assets_canonical ON avatar_assets(is_canonical) WHERE is_canonical = TRUE;

-- Characters active kit
CREATE INDEX IF NOT EXISTS idx_characters_active_kit ON characters(active_avatar_kit_id);

-- ============================================================================
-- Grants
-- ============================================================================
GRANT SELECT ON avatar_kits TO authenticated;
GRANT ALL ON avatar_kits TO service_role;

GRANT SELECT ON avatar_assets TO authenticated;
GRANT ALL ON avatar_assets TO service_role;

-- Update grants for renamed table
GRANT SELECT, INSERT, UPDATE ON scene_images TO authenticated;
GRANT ALL ON scene_images TO service_role;

-- ============================================================================
-- Triggers
-- ============================================================================

-- Updated_at trigger for avatar_kits
CREATE TRIGGER avatar_kits_updated_at
    BEFORE UPDATE ON avatar_kits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- ============================================================================
-- Helper function: Get character's active avatar kit with assets
-- ============================================================================
CREATE OR REPLACE FUNCTION get_character_avatar_kit(p_character_id UUID)
RETURNS TABLE (
    kit_id UUID,
    kit_name TEXT,
    appearance_prompt TEXT,
    style_prompt TEXT,
    negative_prompt TEXT,
    primary_anchor_path TEXT,
    secondary_anchor_path TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        ak.id as kit_id,
        ak.name as kit_name,
        ak.appearance_prompt,
        ak.style_prompt,
        ak.negative_prompt,
        pa.storage_path as primary_anchor_path,
        sa.storage_path as secondary_anchor_path
    FROM characters c
    JOIN avatar_kits ak ON ak.id = c.active_avatar_kit_id
    LEFT JOIN avatar_assets pa ON pa.id = ak.primary_anchor_id
    LEFT JOIN avatar_assets sa ON sa.id = ak.secondary_anchor_id
    WHERE c.id = p_character_id
        AND ak.status = 'active';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION get_character_avatar_kit(UUID) TO authenticated, service_role;

-- ============================================================================
-- Update get_user_memories to work with renamed table
-- ============================================================================
CREATE OR REPLACE FUNCTION get_user_memories(
    p_user_id UUID,
    p_character_id UUID DEFAULT NULL,
    p_limit INTEGER DEFAULT 50
)
RETURNS TABLE (
    image_id UUID,
    episode_id UUID,
    character_id UUID,
    character_name TEXT,
    caption TEXT,
    storage_path TEXT,
    style_tags TEXT[],
    saved_at TIMESTAMPTZ,
    episode_started_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        ia.id as image_id,
        si.episode_id,
        e.character_id,
        c.name as character_name,
        si.caption,
        ia.storage_path,
        ia.style_tags,
        si.saved_at,
        e.started_at as episode_started_at
    FROM scene_images si
    JOIN image_assets ia ON ia.id = si.image_id
    JOIN episodes e ON e.id = si.episode_id
    JOIN characters c ON c.id = e.character_id
    WHERE e.user_id = p_user_id
        AND si.is_memory = TRUE
        AND (p_character_id IS NULL OR e.character_id = p_character_id)
    ORDER BY si.saved_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- Update get_next_episode_image_index to work with renamed table
-- ============================================================================
CREATE OR REPLACE FUNCTION get_next_episode_image_index(p_episode_id UUID)
RETURNS INTEGER AS $$
DECLARE
    next_index INTEGER;
BEGIN
    SELECT COALESCE(MAX(sequence_index) + 1, 0)
    INTO next_index
    FROM scene_images
    WHERE episode_id = p_episode_id;

    RETURN next_index;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- Helper function: Get avatar kit assets by type
-- ============================================================================
CREATE OR REPLACE FUNCTION get_avatar_kit_assets(
    p_kit_id UUID,
    p_asset_type TEXT DEFAULT NULL
)
RETURNS TABLE (
    asset_id UUID,
    asset_type TEXT,
    expression TEXT,
    storage_path TEXT,
    is_canonical BOOLEAN,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        aa.id as asset_id,
        aa.asset_type,
        aa.expression,
        aa.storage_path,
        aa.is_canonical,
        aa.created_at
    FROM avatar_assets aa
    WHERE aa.avatar_kit_id = p_kit_id
        AND aa.is_active = TRUE
        AND (p_asset_type IS NULL OR aa.asset_type = p_asset_type)
    ORDER BY aa.is_canonical DESC, aa.created_at ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION get_avatar_kit_assets(UUID, TEXT) TO authenticated, service_role;
