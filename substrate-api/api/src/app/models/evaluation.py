"""Session Evaluation models.

Evaluations are "reports" generated by Director at episode completion.
They represent shareable results like flirt archetype, mystery summary, etc.

Reference: docs/DIRECTOR_ARCHITECTURE.md, docs/plans/FLIRT_TEST_IMPLEMENTATION_PLAN.md
"""

import json
import secrets
import string
from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Field, field_validator


class EvaluationType:
    """Evaluation type constants."""
    FLIRT_ARCHETYPE = "flirt_archetype"
    MYSTERY_SUMMARY = "mystery_summary"
    COMPATIBILITY = "compatibility"
    EPISODE_SUMMARY = "episode_summary"


class FlirtArchetype:
    """Flirt archetype constants (per implementation plan)."""
    TENSION_BUILDER = "tension_builder"
    BOLD_MOVER = "bold_mover"
    PLAYFUL_TEASE = "playful_tease"
    SLOW_BURN = "slow_burn"
    MYSTERIOUS_ALLURE = "mysterious_allure"


# Archetype metadata for display
FLIRT_ARCHETYPES = {
    FlirtArchetype.TENSION_BUILDER: {
        "title": "The Tension Builder",
        "description": "You know exactly when to pause, when to hold back, when to let anticipation do the work.",
        "signals": ["pause_mastery", "anticipation_building", "comfortable_silence"],
    },
    FlirtArchetype.BOLD_MOVER: {
        "title": "The Bold Mover",
        "description": "Direct, confident, you say what you want. No games, just magnetic clarity.",
        "signals": ["direct_expression", "confident_initiation", "clear_interest"],
    },
    FlirtArchetype.PLAYFUL_TEASE: {
        "title": "The Playful Tease",
        "description": "Light, fun, and impossible to pin down. You keep it breezy and leave them smiling.",
        "signals": ["humor_usage", "playful_banter", "light_energy"],
    },
    FlirtArchetype.SLOW_BURN: {
        "title": "The Slow Burn",
        "description": "Patient and deliberate, you build connection layer by layer. Depth over speed.",
        "signals": ["deep_questions", "genuine_curiosity", "patient_pacing"],
    },
    FlirtArchetype.MYSTERIOUS_ALLURE: {
        "title": "The Mysterious Allure",
        "description": "Intriguing and elusive, you reveal just enough to leave them wanting more.",
        "signals": ["selective_sharing", "intriguing_deflection", "magnetic_mystery"],
    },
}


def generate_share_id(length: int = 8) -> str:
    """Generate URL-safe share ID."""
    alphabet = string.ascii_lowercase + string.digits
    return ''.join(secrets.choice(alphabet) for _ in range(length))


class FlirtArchetypeResult(BaseModel):
    """Structured result for flirt archetype evaluation."""
    archetype: str
    confidence: float = Field(..., ge=0.0, le=1.0)
    primary_signals: List[str] = Field(default_factory=list)
    title: str
    description: str

    @classmethod
    def from_archetype(cls, archetype: str, confidence: float, signals: List[str]) -> "FlirtArchetypeResult":
        """Create result from archetype key."""
        metadata = FLIRT_ARCHETYPES.get(archetype, FLIRT_ARCHETYPES[FlirtArchetype.PLAYFUL_TEASE])
        return cls(
            archetype=archetype,
            confidence=confidence,
            primary_signals=signals,
            title=metadata["title"],
            description=metadata["description"],
        )


class SessionEvaluation(BaseModel):
    """Session evaluation model - shareable result.

    Created by Director when an episode completes.
    Contains the evaluation result and share infrastructure.
    """
    id: UUID
    session_id: UUID

    # Evaluation identity
    evaluation_type: str

    # The evaluation result (schema depends on type)
    result: Dict[str, Any] = Field(default_factory=dict)

    # Share infrastructure
    share_id: Optional[str] = None
    share_count: int = 0

    # LLM tracking
    model_used: Optional[str] = None

    # Timestamp
    created_at: datetime

    @field_validator("result", mode="before")
    @classmethod
    def ensure_result_is_dict(cls, v: Any) -> Dict[str, Any]:
        """Handle result as JSON string (from DB)."""
        if v is None:
            return {}
        if isinstance(v, dict):
            return v
        if isinstance(v, str):
            try:
                parsed = json.loads(v)
                if isinstance(parsed, dict):
                    return parsed
            except (json.JSONDecodeError, TypeError):
                return {"raw": v}
        return {}

    class Config:
        from_attributes = True

    def get_flirt_result(self) -> Optional[FlirtArchetypeResult]:
        """Parse result as FlirtArchetypeResult if applicable."""
        if self.evaluation_type != EvaluationType.FLIRT_ARCHETYPE:
            return None
        return FlirtArchetypeResult(**self.result)


class SessionEvaluationCreate(BaseModel):
    """Input for creating a session evaluation."""
    session_id: UUID
    evaluation_type: str
    result: Dict[str, Any]
    model_used: Optional[str] = None
    generate_share_id: bool = True  # Whether to generate a share_id


class SessionEvaluationSummary(BaseModel):
    """Minimal evaluation info for lists and share pages."""
    id: UUID
    evaluation_type: str
    result: Dict[str, Any]
    share_id: Optional[str] = None
    share_count: int = 0
    created_at: datetime


class ShareableResult(BaseModel):
    """Public-facing shareable result (for share pages).

    Contains only what's needed for the share page display.
    Does not expose session_id or other internal details.
    """
    evaluation_type: str
    result: Dict[str, Any]
    share_id: str
    share_count: int
    created_at: datetime

    # Optional: character info for "continue with character" CTA
    character_name: Optional[str] = None
    character_id: Optional[UUID] = None
    series_id: Optional[UUID] = None
